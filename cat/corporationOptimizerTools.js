import * as comlink from "/libs/comlink";
import {
  BenchmarkType,
  CorporationOptimizer,
  defaultPerformanceModifierForOfficeBenchmark,
  getComparator,
  getReferenceData,
  minStepForOfficeBenchmark
} from "/corporationOptimizer";
import { calculateEmployeeStats, formatNumber, ResearchName } from "/corporationFormulas";
import {
  getCorporationUpgradeLevels,
  getDivisionResearches,
  isProduct,
  Logger,
  sampleProductName
} from "/corporationUtils";
import { generateBlobUrl } from "/scriptUtils";
let workerModuleUrl = new CorporationOptimizer().getScriptUrl();
async function validateWorkerModuleUrl(ns) {
  let fetchResult;
  let valid = true;
  try {
    fetchResult = await fetch(workerModuleUrl);
  } catch (e) {
    valid = false;
  }
  if (fetchResult && !fetchResult.ok) {
    valid = false;
  }
  if (!valid) {
    workerModuleUrl = generateBlobUrl(ns, "corporationOptimizer.js");
  }
}
async function splitWorkload(nsx, divisionName, city, operationsJob, engineerJob, managementJob, workload, logger) {
  const numberOfThreads = globalThis.navigator?.hardwareConcurrency ?? 8;
  const workers = [];
  const promises = [];
  let current = operationsJob.min;
  const step = Math.floor((operationsJob.max - operationsJob.min) / numberOfThreads);
  const loggerLabel = `Office benchmark execution time: ${divisionName}|${city}|${Date.now()}`;
  logger.time(loggerLabel);
  for (let i = 0; i < numberOfThreads; ++i) {
    const from = current;
    if (from > operationsJob.max) {
      break;
    }
    const to = Math.min(current + step, operationsJob.max);
    logger.log(`from: ${from}, to: ${to}`);
    const worker = new Worker(workerModuleUrl, { type: "module" });
    workers.push(worker);
    const workerWrapper = comlink.wrap(worker);
    promises.push(
      workload(
        worker,
        workerWrapper,
        {
          min: from,
          max: to
        },
        {
          min: engineerJob.min,
          max: engineerJob.max
        },
        {
          min: managementJob.min,
          max: managementJob.max
        }
      )
    );
    current += step + 1;
  }
  nsx.addAtExitCallback(() => {
    workers.forEach((worker) => {
      worker.terminate();
    });
  });
  await Promise.allSettled(promises);
  logger.timeLog(loggerLabel);
}
async function optimizeOffice(nsx, division, industryData, city, nonRnDEmployees, rndEmployee, item, useCurrentItemData, sortType, balancingModifierForProfitProgress, maxRerun = 1, performanceModifier = defaultPerformanceModifierForOfficeBenchmark, enableLogging = false, employeeJobsRequirement) {
  if (useCurrentItemData && item.name === sampleProductName) {
    throw new Error("Do not use useCurrentItemData = true with sample product");
  }
  await validateWorkerModuleUrl(nsx.ns);
  const logger = new Logger(enableLogging);
  const data = [];
  const office = nsx.ns.corporation.getOffice(division.name, city);
  let avgMorale = office.avgMorale;
  let avgEnergy = office.avgEnergy;
  const corporationUpgradeLevels = getCorporationUpgradeLevels(nsx.ns);
  const divisionResearches = getDivisionResearches(nsx.ns, division.name);
  if (nonRnDEmployees < 4) {
    throw new Error(`Invalid employees' data. maxTotalEmployees: ${nonRnDEmployees}`);
  }
  const numberOfNewEmployees = nonRnDEmployees + rndEmployee - office.numEmployees;
  if (numberOfNewEmployees < 0) {
    throw new Error(`Invalid employees' data. maxTotalEmployees: ${nonRnDEmployees}, numberOfNewEmployees: ${numberOfNewEmployees}`);
  }
  const totalExperience = office.totalExperience + 75 * numberOfNewEmployees;
  let avgStats;
  try {
    avgStats = await calculateEmployeeStats(
      {
        avgMorale: office.avgMorale,
        avgEnergy: office.avgEnergy,
        totalExperience: office.totalExperience,
        numEmployees: office.numEmployees,
        employeeJobs: office.employeeJobs,
        employeeProductionByJob: office.employeeProductionByJob
      },
      corporationUpgradeLevels,
      divisionResearches
    );
  } catch (e) {
    logger.warn(e);
    avgStats = {
      avgIntelligence: 75,
      avgCharisma: 75,
      avgCreativity: 75,
      avgEfficiency: 75
    };
  }
  for (let i = 0; i < numberOfNewEmployees; i++) {
    avgMorale = divisionResearches[ResearchName.STIMU] ? 110 : 100;
    avgEnergy = divisionResearches[ResearchName.GO_JUICE] ? 110 : 100;
    avgStats.avgIntelligence = (avgStats.avgIntelligence * office.numEmployees + 75) / (office.numEmployees + 1);
    avgStats.avgCharisma = (avgStats.avgCharisma * office.numEmployees + 75) / (office.numEmployees + 1);
    avgStats.avgCreativity = (avgStats.avgCreativity * office.numEmployees + 75) / (office.numEmployees + 1);
    avgStats.avgEfficiency = (avgStats.avgEfficiency * office.numEmployees + 75) / (office.numEmployees + 1);
  }
  const customData = {
    office: {
      avgMorale,
      avgEnergy,
      avgIntelligence: avgStats.avgIntelligence,
      avgCharisma: avgStats.avgCharisma,
      avgCreativity: avgStats.avgCreativity,
      avgEfficiency: avgStats.avgEfficiency,
      totalExperience
    },
    corporationUpgradeLevels,
    divisionResearches,
    performanceModifier
  };
  const printDataEntryLog = (dataEntry) => {
    let message = `{operations:${dataEntry.operations}, engineer:${dataEntry.engineer}, business:${dataEntry.business}, management:${dataEntry.management}, `;
    message += `totalExperience:${formatNumber(dataEntry.totalExperience)}, `;
    message += `rawProduction:${formatNumber(dataEntry.rawProduction)}, maxSalesVolume:${formatNumber(dataEntry.maxSalesVolume)}, optimalPrice:${formatNumber(dataEntry.optimalPrice)}, profit:${dataEntry.profit.toExponential(5)}, salesEfficiency: ${Math.min(dataEntry.maxSalesVolume / dataEntry.rawProduction, 1).toFixed(3)}`;
    if (isProduct(item)) {
      message += `, progress: ${dataEntry.productDevelopmentProgress.toFixed(5)}`;
      message += `, progressCycle: ${Math.ceil(100 / dataEntry.productDevelopmentProgress)}`;
      message += `, estimatedRP: ${formatNumber(dataEntry.estimatedRP)}`;
      message += `, rating: ${formatNumber(dataEntry.productRating)}`;
      message += `, markup: ${formatNumber(dataEntry.productMarkup)}`;
      message += `, profit_progress: ${(dataEntry.profit * dataEntry.productDevelopmentProgress).toExponential(5)}}`;
    } else {
      message += "}";
    }
    logger.log(message);
  };
  const referenceData = await getReferenceData(
    division,
    industryData,
    nonRnDEmployees,
    item,
    useCurrentItemData,
    customData
  );
  const comparatorCustomData = {
    referenceData,
    balancingModifierForProfitProgress
  };
  let nonRnDEmployeesWithRequirement = nonRnDEmployees;
  if (employeeJobsRequirement) {
    nonRnDEmployeesWithRequirement = nonRnDEmployees - employeeJobsRequirement.engineer - employeeJobsRequirement.business;
  }
  const min = 1;
  const max = Math.floor(nonRnDEmployeesWithRequirement * 0.6);
  let maxUsedStep = 0;
  let error;
  const workload = async (worker, workerWrapper, operationsJob, engineerJob, managementJob) => {
    maxUsedStep = 0;
    return workerWrapper.optimizeOffice(
      division,
      industryData,
      {
        min: operationsJob.min,
        max: operationsJob.max
      },
      {
        min: engineerJob.min,
        max: engineerJob.max
      },
      {
        min: managementJob.min,
        max: managementJob.max
      },
      rndEmployee,
      nonRnDEmployees,
      // Do not use nonRnDEmployeesWithRequirement
      item,
      useCurrentItemData,
      customData,
      sortType,
      comparatorCustomData,
      enableLogging,
      employeeJobsRequirement
    ).then((result) => {
      maxUsedStep = Math.max(maxUsedStep, result.step);
      data.push(...result.data);
      worker.terminate();
    }).catch((reason) => {
      console.error(reason);
      error = reason;
    });
  };
  const operationsMin = min;
  const operationsMax = max;
  let engineerMin = min;
  let engineerMax = max;
  const managementMin = min;
  const managementMax = max;
  if (employeeJobsRequirement) {
    engineerMin = employeeJobsRequirement.engineer;
    engineerMax = employeeJobsRequirement.engineer;
  }
  await splitWorkload(
    nsx,
    division.name,
    city,
    {
      min: operationsMin,
      max: operationsMax
    },
    {
      min: engineerMin,
      max: engineerMax
    },
    {
      min: managementMin,
      max: managementMax
    },
    workload,
    logger
  );
  if (error) {
    throw new Error(`Error occurred in worker: ${JSON.stringify(error)}`);
  }
  data.sort(getComparator(BenchmarkType.OFFICE, sortType, comparatorCustomData));
  let count = 0;
  while (true) {
    logger.log(`maxUsedStep: ${maxUsedStep}`);
    if (count >= maxRerun) {
      break;
    }
    if (maxUsedStep === minStepForOfficeBenchmark) {
      break;
    }
    logger.log("Rerun benchmark to get more accurate data");
    const currentBestResult = data[data.length - 1];
    logger.log("Current best result:");
    printDataEntryLog(currentBestResult);
    let newEngineerMin = Math.max(currentBestResult.engineer - maxUsedStep, 1);
    let newEngineerMax = Math.min(currentBestResult.engineer + maxUsedStep, nonRnDEmployees - 3);
    if (employeeJobsRequirement) {
      newEngineerMin = employeeJobsRequirement.engineer;
      newEngineerMax = employeeJobsRequirement.engineer;
    }
    await splitWorkload(
      nsx,
      division.name,
      city,
      {
        min: Math.max(currentBestResult.operations - maxUsedStep, 1),
        max: Math.min(currentBestResult.operations + maxUsedStep, nonRnDEmployees - 3)
      },
      {
        min: newEngineerMin,
        max: newEngineerMax
      },
      {
        min: Math.max(currentBestResult.management - maxUsedStep, 1),
        max: Math.min(currentBestResult.management + maxUsedStep, nonRnDEmployees - 3)
      },
      workload,
      logger
    );
    if (error) {
      throw new Error(`Error occurred in worker: ${JSON.stringify(error)}`);
    }
    data.sort(getComparator(BenchmarkType.OFFICE, sortType, comparatorCustomData));
    ++count;
  }
  let dataForLogging = data;
  if (dataForLogging.length > 10) {
    dataForLogging = dataForLogging.slice(-10);
  }
  dataForLogging.forEach((dataEntry) => {
    printDataEntryLog(dataEntry);
  });
  return data;
}
export {
  optimizeOffice
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2NvcnBvcmF0aW9uT3B0aW1pemVyVG9vbHMudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7Q29ycEluZHVzdHJ5RGF0YSwgRGl2aXNpb24sIE1hdGVyaWFsLCBOUywgUHJvZHVjdCx9IGZyb20gXCJAbnNcIjtcclxuaW1wb3J0ICogYXMgY29tbGluayBmcm9tIFwiL2xpYnMvY29tbGlua1wiO1xyXG5pbXBvcnQge1JlbW90ZX0gZnJvbSBcIi9saWJzL2NvbWxpbmtcIjtcclxuaW1wb3J0IHtcclxuICAgIEJhbGFuY2luZ01vZGlmaWVyRm9yUHJvZml0UHJvZ3Jlc3MsXHJcbiAgICBCZW5jaG1hcmtUeXBlLFxyXG4gICAgQ29tcGFyYXRvckN1c3RvbURhdGEsXHJcbiAgICBDb3Jwb3JhdGlvbk9wdGltaXplcixcclxuICAgIGRlZmF1bHRQZXJmb3JtYW5jZU1vZGlmaWVyRm9yT2ZmaWNlQmVuY2htYXJrLFxyXG4gICAgRW1wbG95ZWVKb2JSZXF1aXJlbWVudCxcclxuICAgIGdldENvbXBhcmF0b3IsXHJcbiAgICBnZXRSZWZlcmVuY2VEYXRhLFxyXG4gICAgbWluU3RlcEZvck9mZmljZUJlbmNobWFyayxcclxuICAgIE9mZmljZUJlbmNobWFya0N1c3RvbURhdGEsXHJcbiAgICBPZmZpY2VCZW5jaG1hcmtEYXRhLFxyXG4gICAgT2ZmaWNlQmVuY2htYXJrU29ydFR5cGVcclxufSBmcm9tIFwiL2NvcnBvcmF0aW9uT3B0aW1pemVyXCI7XHJcbmltcG9ydCB7Y2FsY3VsYXRlRW1wbG95ZWVTdGF0cywgQ2l0eU5hbWUsIGZvcm1hdE51bWJlciwgUmVzZWFyY2hOYW1lfSBmcm9tIFwiL2NvcnBvcmF0aW9uRm9ybXVsYXNcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldENvcnBvcmF0aW9uVXBncmFkZUxldmVscyxcclxuICAgIGdldERpdmlzaW9uUmVzZWFyY2hlcyxcclxuICAgIGlzUHJvZHVjdCxcclxuICAgIExvZ2dlcixcclxuICAgIHNhbXBsZVByb2R1Y3ROYW1lXHJcbn0gZnJvbSBcIi9jb3Jwb3JhdGlvblV0aWxzXCI7XHJcbmltcG9ydCB7Z2VuZXJhdGVCbG9iVXJsfSBmcm9tIFwiL3NjcmlwdFV0aWxzXCI7XHJcbmltcG9ydCB7U2NyaXB0RmlsZVBhdGh9IGZyb20gXCIvbGlicy9wYXRocy9TY3JpcHRGaWxlUGF0aFwiO1xyXG5pbXBvcnQge05ldHNjcmlwdEV4dGVuc2lvbn0gZnJvbSBcIi9saWJzL05ldHNjcmlwdEV4dGVuc2lvblwiO1xyXG5cclxubGV0IHdvcmtlck1vZHVsZVVybCA9IG5ldyBDb3Jwb3JhdGlvbk9wdGltaXplcigpLmdldFNjcmlwdFVybCgpO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVXb3JrZXJNb2R1bGVVcmwobnM6IE5TKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBsZXQgZmV0Y2hSZXN1bHQ7XHJcbiAgICBsZXQgdmFsaWQgPSB0cnVlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBmZXRjaFJlc3VsdCA9IGF3YWl0IGZldGNoKHdvcmtlck1vZHVsZVVybCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgdmFsaWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChmZXRjaFJlc3VsdCAmJiAhZmV0Y2hSZXN1bHQub2spIHtcclxuICAgICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCF2YWxpZCkge1xyXG4gICAgICAgIHdvcmtlck1vZHVsZVVybCA9IGdlbmVyYXRlQmxvYlVybChucywgXCJjb3Jwb3JhdGlvbk9wdGltaXplci5qc1wiIGFzIFNjcmlwdEZpbGVQYXRoKTtcclxuICAgIH1cclxufVxyXG5cclxudHlwZSBXb3JrbG9hZCA9IChcclxuICAgIHdvcmtlcjogV29ya2VyLFxyXG4gICAgd29ya2VyV3JhcHBlcjogUmVtb3RlPENvcnBvcmF0aW9uT3B0aW1pemVyPixcclxuICAgIG9wZXJhdGlvbnNKb2I6IHtcclxuICAgICAgICBtaW46IG51bWJlcjtcclxuICAgICAgICBtYXg6IG51bWJlcjtcclxuICAgIH0sXHJcbiAgICBlbmdpbmVlckpvYjoge1xyXG4gICAgICAgIG1pbjogbnVtYmVyO1xyXG4gICAgICAgIG1heDogbnVtYmVyO1xyXG4gICAgfSxcclxuICAgIG1hbmFnZW1lbnRKb2I6IHtcclxuICAgICAgICBtaW46IG51bWJlcjtcclxuICAgICAgICBtYXg6IG51bWJlcjtcclxuICAgIH1cclxuKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gc3BsaXRXb3JrbG9hZChcclxuICAgIG5zeDogTmV0c2NyaXB0RXh0ZW5zaW9uLFxyXG4gICAgZGl2aXNpb25OYW1lOiBzdHJpbmcsXHJcbiAgICBjaXR5OiBDaXR5TmFtZSxcclxuICAgIG9wZXJhdGlvbnNKb2I6IHtcclxuICAgICAgICBtaW46IG51bWJlcjtcclxuICAgICAgICBtYXg6IG51bWJlcjtcclxuICAgIH0sXHJcbiAgICBlbmdpbmVlckpvYjoge1xyXG4gICAgICAgIG1pbjogbnVtYmVyO1xyXG4gICAgICAgIG1heDogbnVtYmVyO1xyXG4gICAgfSxcclxuICAgIG1hbmFnZW1lbnRKb2I6IHtcclxuICAgICAgICBtaW46IG51bWJlcjtcclxuICAgICAgICBtYXg6IG51bWJlcjtcclxuICAgIH0sXHJcbiAgICB3b3JrbG9hZDogV29ya2xvYWQsXHJcbiAgICBsb2dnZXI6IExvZ2dlclxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IG51bWJlck9mVGhyZWFkcyA9IGdsb2JhbFRoaXMubmF2aWdhdG9yPy5oYXJkd2FyZUNvbmN1cnJlbmN5ID8/IDg7XHJcbiAgICBjb25zdCB3b3JrZXJzOiBXb3JrZXJbXSA9IFtdO1xyXG4gICAgY29uc3QgcHJvbWlzZXM6IFByb21pc2U8dm9pZD5bXSA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnQgPSBvcGVyYXRpb25zSm9iLm1pbjtcclxuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLmZsb29yKChvcGVyYXRpb25zSm9iLm1heCAtIG9wZXJhdGlvbnNKb2IubWluKSAvIG51bWJlck9mVGhyZWFkcyk7XHJcbiAgICBjb25zdCBsb2dnZXJMYWJlbCA9IGBPZmZpY2UgYmVuY2htYXJrIGV4ZWN1dGlvbiB0aW1lOiAke2RpdmlzaW9uTmFtZX18JHtjaXR5fXwke0RhdGUubm93KCl9YDtcclxuICAgIGxvZ2dlci50aW1lKGxvZ2dlckxhYmVsKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUaHJlYWRzOyArK2kpIHtcclxuICAgICAgICBjb25zdCBmcm9tID0gY3VycmVudDtcclxuICAgICAgICBpZiAoZnJvbSA+IG9wZXJhdGlvbnNKb2IubWF4KSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0byA9IE1hdGgubWluKGN1cnJlbnQgKyBzdGVwLCBvcGVyYXRpb25zSm9iLm1heCk7XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhgZnJvbTogJHtmcm9tfSwgdG86ICR7dG99YCk7XHJcbiAgICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJNb2R1bGVVcmwsIHt0eXBlOiBcIm1vZHVsZVwifSk7XHJcbiAgICAgICAgd29ya2Vycy5wdXNoKHdvcmtlcik7XHJcbiAgICAgICAgY29uc3Qgd29ya2VyV3JhcHBlciA9IGNvbWxpbmsud3JhcDxDb3Jwb3JhdGlvbk9wdGltaXplcj4od29ya2VyKTtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICB3b3JrbG9hZChcclxuICAgICAgICAgICAgICAgIHdvcmtlcixcclxuICAgICAgICAgICAgICAgIHdvcmtlcldyYXBwZXIsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluOiBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heDogdG9cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluOiBlbmdpbmVlckpvYi5taW4sXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBlbmdpbmVlckpvYi5tYXhcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluOiBtYW5hZ2VtZW50Sm9iLm1pbixcclxuICAgICAgICAgICAgICAgICAgICBtYXg6IG1hbmFnZW1lbnRKb2IubWF4XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICAgIGN1cnJlbnQgKz0gKHN0ZXAgKyAxKTtcclxuICAgIH1cclxuICAgIG5zeC5hZGRBdEV4aXRDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgd29ya2Vycy5mb3JFYWNoKHdvcmtlciA9PiB7XHJcbiAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHByb21pc2VzKTtcclxuICAgIGxvZ2dlci50aW1lTG9nKGxvZ2dlckxhYmVsKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG9wdGltaXplT2ZmaWNlKFxyXG4gICAgbnN4OiBOZXRzY3JpcHRFeHRlbnNpb24sXHJcbiAgICBkaXZpc2lvbjogRGl2aXNpb24sXHJcbiAgICBpbmR1c3RyeURhdGE6IENvcnBJbmR1c3RyeURhdGEsXHJcbiAgICBjaXR5OiBDaXR5TmFtZSxcclxuICAgIG5vblJuREVtcGxveWVlczogbnVtYmVyLFxyXG4gICAgcm5kRW1wbG95ZWU6IG51bWJlcixcclxuICAgIGl0ZW06IE1hdGVyaWFsIHwgUHJvZHVjdCxcclxuICAgIHVzZUN1cnJlbnRJdGVtRGF0YTogYm9vbGVhbixcclxuICAgIHNvcnRUeXBlOiBPZmZpY2VCZW5jaG1hcmtTb3J0VHlwZSxcclxuICAgIGJhbGFuY2luZ01vZGlmaWVyRm9yUHJvZml0UHJvZ3Jlc3M6IEJhbGFuY2luZ01vZGlmaWVyRm9yUHJvZml0UHJvZ3Jlc3MsXHJcbiAgICBtYXhSZXJ1biA9IDEsXHJcbiAgICBwZXJmb3JtYW5jZU1vZGlmaWVyID0gZGVmYXVsdFBlcmZvcm1hbmNlTW9kaWZpZXJGb3JPZmZpY2VCZW5jaG1hcmssXHJcbiAgICBlbmFibGVMb2dnaW5nID0gZmFsc2UsXHJcbiAgICBlbXBsb3llZUpvYnNSZXF1aXJlbWVudD86IEVtcGxveWVlSm9iUmVxdWlyZW1lbnRcclxuKTogUHJvbWlzZTxPZmZpY2VCZW5jaG1hcmtEYXRhW10+IHtcclxuICAgIGlmICh1c2VDdXJyZW50SXRlbURhdGEgJiYgaXRlbS5uYW1lID09PSBzYW1wbGVQcm9kdWN0TmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvIG5vdCB1c2UgdXNlQ3VycmVudEl0ZW1EYXRhID0gdHJ1ZSB3aXRoIHNhbXBsZSBwcm9kdWN0XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGF3YWl0IHZhbGlkYXRlV29ya2VyTW9kdWxlVXJsKG5zeC5ucyk7XHJcblxyXG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcihlbmFibGVMb2dnaW5nKTtcclxuICAgIGNvbnN0IGRhdGE6IE9mZmljZUJlbmNobWFya0RhdGFbXSA9IFtdO1xyXG4gICAgY29uc3Qgb2ZmaWNlID0gbnN4Lm5zLmNvcnBvcmF0aW9uLmdldE9mZmljZShkaXZpc2lvbi5uYW1lLCBjaXR5KTtcclxuXHJcbiAgICBsZXQgYXZnTW9yYWxlID0gb2ZmaWNlLmF2Z01vcmFsZTtcclxuICAgIGxldCBhdmdFbmVyZ3kgPSBvZmZpY2UuYXZnRW5lcmd5O1xyXG4gICAgY29uc3QgY29ycG9yYXRpb25VcGdyYWRlTGV2ZWxzID0gZ2V0Q29ycG9yYXRpb25VcGdyYWRlTGV2ZWxzKG5zeC5ucyk7XHJcbiAgICBjb25zdCBkaXZpc2lvblJlc2VhcmNoZXMgPSBnZXREaXZpc2lvblJlc2VhcmNoZXMobnN4Lm5zLCBkaXZpc2lvbi5uYW1lKTtcclxuXHJcbiAgICBpZiAobm9uUm5ERW1wbG95ZWVzIDwgNCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbXBsb3llZXMnIGRhdGEuIG1heFRvdGFsRW1wbG95ZWVzOiAke25vblJuREVtcGxveWVlc31gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBudW1iZXJPZk5ld0VtcGxveWVlcyA9XHJcbiAgICAgICAgbm9uUm5ERW1wbG95ZWVzXHJcbiAgICAgICAgKyBybmRFbXBsb3llZVxyXG4gICAgICAgIC0gb2ZmaWNlLm51bUVtcGxveWVlcztcclxuICAgIGlmIChudW1iZXJPZk5ld0VtcGxveWVlcyA8IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZW1wbG95ZWVzJyBkYXRhLiBtYXhUb3RhbEVtcGxveWVlczogJHtub25SbkRFbXBsb3llZXN9LCBudW1iZXJPZk5ld0VtcGxveWVlczogJHtudW1iZXJPZk5ld0VtcGxveWVlc31gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRvdGFsRXhwZXJpZW5jZSA9IG9mZmljZS50b3RhbEV4cGVyaWVuY2UgKyA3NSAqIG51bWJlck9mTmV3RW1wbG95ZWVzO1xyXG4gICAgLy8gQ2FsY3VsYXRlIGF2Z1N0YXRzIGJhc2VkIG9uIGN1cnJlbnQgb2ZmaWNlIGRhdGFcclxuICAgIGxldCBhdmdTdGF0cztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXZnU3RhdHMgPSBhd2FpdCBjYWxjdWxhdGVFbXBsb3llZVN0YXRzKFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhdmdNb3JhbGU6IG9mZmljZS5hdmdNb3JhbGUsXHJcbiAgICAgICAgICAgICAgICBhdmdFbmVyZ3k6IG9mZmljZS5hdmdFbmVyZ3ksXHJcbiAgICAgICAgICAgICAgICB0b3RhbEV4cGVyaWVuY2U6IG9mZmljZS50b3RhbEV4cGVyaWVuY2UsXHJcbiAgICAgICAgICAgICAgICBudW1FbXBsb3llZXM6IG9mZmljZS5udW1FbXBsb3llZXMsXHJcbiAgICAgICAgICAgICAgICBlbXBsb3llZUpvYnM6IG9mZmljZS5lbXBsb3llZUpvYnMsXHJcbiAgICAgICAgICAgICAgICBlbXBsb3llZVByb2R1Y3Rpb25CeUpvYjogb2ZmaWNlLmVtcGxveWVlUHJvZHVjdGlvbkJ5Sm9iLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb3Jwb3JhdGlvblVwZ3JhZGVMZXZlbHMsXHJcbiAgICAgICAgICAgIGRpdmlzaW9uUmVzZWFyY2hlc1xyXG4gICAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oZSk7XHJcbiAgICAgICAgYXZnU3RhdHMgPSB7XHJcbiAgICAgICAgICAgIGF2Z0ludGVsbGlnZW5jZTogNzUsXHJcbiAgICAgICAgICAgIGF2Z0NoYXJpc21hOiA3NSxcclxuICAgICAgICAgICAgYXZnQ3JlYXRpdml0eTogNzUsXHJcbiAgICAgICAgICAgIGF2Z0VmZmljaWVuY3k6IDc1LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mTmV3RW1wbG95ZWVzOyBpKyspIHtcclxuICAgICAgICAvLyBhdmdNb3JhbGUgPSAoYXZnTW9yYWxlICogb2ZmaWNlLm51bUVtcGxveWVlcyArIDc1KSAvIChvZmZpY2UubnVtRW1wbG95ZWVzICsgMSk7XHJcbiAgICAgICAgLy8gYXZnRW5lcmd5ID0gKGF2Z0VuZXJneSAqIG9mZmljZS5udW1FbXBsb3llZXMgKyA3NSkgLyAob2ZmaWNlLm51bUVtcGxveWVlcyArIDEpO1xyXG4gICAgICAgIC8vIEFzc3VtZSB0aGF0IHdlIGFsd2F5cyBtYWludGFpbiBtYXggbW9yYWxlL2VuZXJneVxyXG4gICAgICAgIGF2Z01vcmFsZSA9IGRpdmlzaW9uUmVzZWFyY2hlc1tSZXNlYXJjaE5hbWUuU1RJTVVdID8gMTEwIDogMTAwO1xyXG4gICAgICAgIGF2Z0VuZXJneSA9IGRpdmlzaW9uUmVzZWFyY2hlc1tSZXNlYXJjaE5hbWUuR09fSlVJQ0VdID8gMTEwIDogMTAwO1xyXG4gICAgICAgIGF2Z1N0YXRzLmF2Z0ludGVsbGlnZW5jZSA9IChhdmdTdGF0cy5hdmdJbnRlbGxpZ2VuY2UgKiBvZmZpY2UubnVtRW1wbG95ZWVzICsgNzUpIC8gKG9mZmljZS5udW1FbXBsb3llZXMgKyAxKTtcclxuICAgICAgICBhdmdTdGF0cy5hdmdDaGFyaXNtYSA9IChhdmdTdGF0cy5hdmdDaGFyaXNtYSAqIG9mZmljZS5udW1FbXBsb3llZXMgKyA3NSkgLyAob2ZmaWNlLm51bUVtcGxveWVlcyArIDEpO1xyXG4gICAgICAgIGF2Z1N0YXRzLmF2Z0NyZWF0aXZpdHkgPSAoYXZnU3RhdHMuYXZnQ3JlYXRpdml0eSAqIG9mZmljZS5udW1FbXBsb3llZXMgKyA3NSkgLyAob2ZmaWNlLm51bUVtcGxveWVlcyArIDEpO1xyXG4gICAgICAgIGF2Z1N0YXRzLmF2Z0VmZmljaWVuY3kgPSAoYXZnU3RhdHMuYXZnRWZmaWNpZW5jeSAqIG9mZmljZS5udW1FbXBsb3llZXMgKyA3NSkgLyAob2ZmaWNlLm51bUVtcGxveWVlcyArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGN1c3RvbURhdGE6IE9mZmljZUJlbmNobWFya0N1c3RvbURhdGEgPSB7XHJcbiAgICAgICAgb2ZmaWNlOiB7XHJcbiAgICAgICAgICAgIGF2Z01vcmFsZTogYXZnTW9yYWxlLFxyXG4gICAgICAgICAgICBhdmdFbmVyZ3k6IGF2Z0VuZXJneSxcclxuICAgICAgICAgICAgYXZnSW50ZWxsaWdlbmNlOiBhdmdTdGF0cy5hdmdJbnRlbGxpZ2VuY2UsXHJcbiAgICAgICAgICAgIGF2Z0NoYXJpc21hOiBhdmdTdGF0cy5hdmdDaGFyaXNtYSxcclxuICAgICAgICAgICAgYXZnQ3JlYXRpdml0eTogYXZnU3RhdHMuYXZnQ3JlYXRpdml0eSxcclxuICAgICAgICAgICAgYXZnRWZmaWNpZW5jeTogYXZnU3RhdHMuYXZnRWZmaWNpZW5jeSxcclxuICAgICAgICAgICAgdG90YWxFeHBlcmllbmNlOiB0b3RhbEV4cGVyaWVuY2UsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb3Jwb3JhdGlvblVwZ3JhZGVMZXZlbHM6IGNvcnBvcmF0aW9uVXBncmFkZUxldmVscyxcclxuICAgICAgICBkaXZpc2lvblJlc2VhcmNoZXM6IGRpdmlzaW9uUmVzZWFyY2hlcyxcclxuICAgICAgICBwZXJmb3JtYW5jZU1vZGlmaWVyOiBwZXJmb3JtYW5jZU1vZGlmaWVyXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJpbnREYXRhRW50cnlMb2cgPSAoZGF0YUVudHJ5OiBPZmZpY2VCZW5jaG1hcmtEYXRhKSA9PiB7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBge29wZXJhdGlvbnM6JHtkYXRhRW50cnkub3BlcmF0aW9uc30sIGVuZ2luZWVyOiR7ZGF0YUVudHJ5LmVuZ2luZWVyfSwgYFxyXG4gICAgICAgICAgICArIGBidXNpbmVzczoke2RhdGFFbnRyeS5idXNpbmVzc30sIG1hbmFnZW1lbnQ6JHtkYXRhRW50cnkubWFuYWdlbWVudH0sIGA7XHJcbiAgICAgICAgbWVzc2FnZSArPSBgdG90YWxFeHBlcmllbmNlOiR7Zm9ybWF0TnVtYmVyKGRhdGFFbnRyeS50b3RhbEV4cGVyaWVuY2UpfSwgYDtcclxuICAgICAgICBtZXNzYWdlICs9XHJcbiAgICAgICAgICAgIGByYXdQcm9kdWN0aW9uOiR7Zm9ybWF0TnVtYmVyKGRhdGFFbnRyeS5yYXdQcm9kdWN0aW9uKX0sIGAgK1xyXG4gICAgICAgICAgICBgbWF4U2FsZXNWb2x1bWU6JHtmb3JtYXROdW1iZXIoZGF0YUVudHJ5Lm1heFNhbGVzVm9sdW1lKX0sIGAgK1xyXG4gICAgICAgICAgICBgb3B0aW1hbFByaWNlOiR7Zm9ybWF0TnVtYmVyKGRhdGFFbnRyeS5vcHRpbWFsUHJpY2UpfSwgYCArXHJcbiAgICAgICAgICAgIGBwcm9maXQ6JHtkYXRhRW50cnkucHJvZml0LnRvRXhwb25lbnRpYWwoNSl9LCBgICtcclxuICAgICAgICAgICAgYHNhbGVzRWZmaWNpZW5jeTogJHtNYXRoLm1pbihkYXRhRW50cnkubWF4U2FsZXNWb2x1bWUgLyBkYXRhRW50cnkucmF3UHJvZHVjdGlvbiwgMSkudG9GaXhlZCgzKX1gO1xyXG4gICAgICAgIGlmIChpc1Byb2R1Y3QoaXRlbSkpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBgLCBwcm9ncmVzczogJHtkYXRhRW50cnkucHJvZHVjdERldmVsb3BtZW50UHJvZ3Jlc3MudG9GaXhlZCg1KX1gO1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IGAsIHByb2dyZXNzQ3ljbGU6ICR7TWF0aC5jZWlsKDEwMCAvIGRhdGFFbnRyeS5wcm9kdWN0RGV2ZWxvcG1lbnRQcm9ncmVzcyl9YDtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBgLCBlc3RpbWF0ZWRSUDogJHtmb3JtYXROdW1iZXIoZGF0YUVudHJ5LmVzdGltYXRlZFJQKX1gO1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IGAsIHJhdGluZzogJHtmb3JtYXROdW1iZXIoZGF0YUVudHJ5LnByb2R1Y3RSYXRpbmcpfWA7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCwgbWFya3VwOiAke2Zvcm1hdE51bWJlcihkYXRhRW50cnkucHJvZHVjdE1hcmt1cCl9YDtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBgLCBwcm9maXRfcHJvZ3Jlc3M6ICR7KGRhdGFFbnRyeS5wcm9maXQgKiBkYXRhRW50cnkucHJvZHVjdERldmVsb3BtZW50UHJvZ3Jlc3MpLnRvRXhwb25lbnRpYWwoNSl9fWA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBcIn1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhtZXNzYWdlKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcmVmZXJlbmNlRGF0YSA9IGF3YWl0IGdldFJlZmVyZW5jZURhdGEoXHJcbiAgICAgICAgZGl2aXNpb24sXHJcbiAgICAgICAgaW5kdXN0cnlEYXRhLFxyXG4gICAgICAgIG5vblJuREVtcGxveWVlcyxcclxuICAgICAgICBpdGVtLFxyXG4gICAgICAgIHVzZUN1cnJlbnRJdGVtRGF0YSxcclxuICAgICAgICBjdXN0b21EYXRhXHJcbiAgICApO1xyXG4gICAgY29uc3QgY29tcGFyYXRvckN1c3RvbURhdGE6IENvbXBhcmF0b3JDdXN0b21EYXRhID0ge1xyXG4gICAgICAgIHJlZmVyZW5jZURhdGE6IHJlZmVyZW5jZURhdGEsXHJcbiAgICAgICAgYmFsYW5jaW5nTW9kaWZpZXJGb3JQcm9maXRQcm9ncmVzczogYmFsYW5jaW5nTW9kaWZpZXJGb3JQcm9maXRQcm9ncmVzc1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBub25SbkRFbXBsb3llZXNXaXRoUmVxdWlyZW1lbnQgaXMgb25seSB1c2VkIGZvciBjYWxjdWxhdGluZyBtaW4vbWF4XHJcbiAgICBsZXQgbm9uUm5ERW1wbG95ZWVzV2l0aFJlcXVpcmVtZW50ID0gbm9uUm5ERW1wbG95ZWVzO1xyXG4gICAgaWYgKGVtcGxveWVlSm9ic1JlcXVpcmVtZW50KSB7XHJcbiAgICAgICAgbm9uUm5ERW1wbG95ZWVzV2l0aFJlcXVpcmVtZW50ID0gbm9uUm5ERW1wbG95ZWVzIC0gZW1wbG95ZWVKb2JzUmVxdWlyZW1lbnQuZW5naW5lZXIgLSBlbXBsb3llZUpvYnNSZXF1aXJlbWVudC5idXNpbmVzcztcclxuICAgIH1cclxuICAgIGNvbnN0IG1pbiA9IDE7XHJcbiAgICBjb25zdCBtYXggPSBNYXRoLmZsb29yKG5vblJuREVtcGxveWVlc1dpdGhSZXF1aXJlbWVudCAqIDAuNik7XHJcbiAgICBsZXQgbWF4VXNlZFN0ZXAgPSAwO1xyXG4gICAgbGV0IGVycm9yOiB1bmtub3duO1xyXG4gICAgY29uc3Qgd29ya2xvYWQ6IFdvcmtsb2FkID0gYXN5bmMgKFxyXG4gICAgICAgIHdvcmtlcjogV29ya2VyLFxyXG4gICAgICAgIHdvcmtlcldyYXBwZXI6IFJlbW90ZTxDb3Jwb3JhdGlvbk9wdGltaXplcj4sXHJcbiAgICAgICAgb3BlcmF0aW9uc0pvYjoge1xyXG4gICAgICAgICAgICBtaW46IG51bWJlcjtcclxuICAgICAgICAgICAgbWF4OiBudW1iZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmdpbmVlckpvYjoge1xyXG4gICAgICAgICAgICBtaW46IG51bWJlcjtcclxuICAgICAgICAgICAgbWF4OiBudW1iZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYW5hZ2VtZW50Sm9iOiB7XHJcbiAgICAgICAgICAgIG1pbjogbnVtYmVyO1xyXG4gICAgICAgICAgICBtYXg6IG51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICApID0+IHtcclxuICAgICAgICBtYXhVc2VkU3RlcCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHdvcmtlcldyYXBwZXIub3B0aW1pemVPZmZpY2UoXHJcbiAgICAgICAgICAgIGRpdmlzaW9uLFxyXG4gICAgICAgICAgICBpbmR1c3RyeURhdGEsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1pbjogb3BlcmF0aW9uc0pvYi5taW4sXHJcbiAgICAgICAgICAgICAgICBtYXg6IG9wZXJhdGlvbnNKb2IubWF4XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1pbjogZW5naW5lZXJKb2IubWluLFxyXG4gICAgICAgICAgICAgICAgbWF4OiBlbmdpbmVlckpvYi5tYXhcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbWluOiBtYW5hZ2VtZW50Sm9iLm1pbixcclxuICAgICAgICAgICAgICAgIG1heDogbWFuYWdlbWVudEpvYi5tYXhcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcm5kRW1wbG95ZWUsXHJcbiAgICAgICAgICAgIG5vblJuREVtcGxveWVlcywgLy8gRG8gbm90IHVzZSBub25SbkRFbXBsb3llZXNXaXRoUmVxdWlyZW1lbnRcclxuICAgICAgICAgICAgaXRlbSxcclxuICAgICAgICAgICAgdXNlQ3VycmVudEl0ZW1EYXRhLFxyXG4gICAgICAgICAgICBjdXN0b21EYXRhLFxyXG4gICAgICAgICAgICBzb3J0VHlwZSxcclxuICAgICAgICAgICAgY29tcGFyYXRvckN1c3RvbURhdGEsXHJcbiAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmcsXHJcbiAgICAgICAgICAgIGVtcGxveWVlSm9ic1JlcXVpcmVtZW50XHJcbiAgICAgICAgKS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIG1heFVzZWRTdGVwID0gTWF0aC5tYXgobWF4VXNlZFN0ZXAsIHJlc3VsdC5zdGVwKTtcclxuICAgICAgICAgICAgZGF0YS5wdXNoKC4uLnJlc3VsdC5kYXRhKTtcclxuICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xyXG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgIC8vIEJ5cGFzcyB1c2FnZSBvZiBsb2dnZXJcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZWFzb24pO1xyXG4gICAgICAgICAgICBlcnJvciA9IHJlYXNvbjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBjb25zdCBvcGVyYXRpb25zTWluID0gbWluO1xyXG4gICAgY29uc3Qgb3BlcmF0aW9uc01heCA9IG1heDtcclxuICAgIGxldCBlbmdpbmVlck1pbiA9IG1pbjtcclxuICAgIGxldCBlbmdpbmVlck1heCA9IG1heDtcclxuICAgIGNvbnN0IG1hbmFnZW1lbnRNaW4gPSBtaW47XHJcbiAgICBjb25zdCBtYW5hZ2VtZW50TWF4ID0gbWF4O1xyXG4gICAgaWYgKGVtcGxveWVlSm9ic1JlcXVpcmVtZW50KSB7XHJcbiAgICAgICAgZW5naW5lZXJNaW4gPSBlbXBsb3llZUpvYnNSZXF1aXJlbWVudC5lbmdpbmVlcjtcclxuICAgICAgICBlbmdpbmVlck1heCA9IGVtcGxveWVlSm9ic1JlcXVpcmVtZW50LmVuZ2luZWVyO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgc3BsaXRXb3JrbG9hZChcclxuICAgICAgICBuc3gsXHJcbiAgICAgICAgZGl2aXNpb24ubmFtZSxcclxuICAgICAgICBjaXR5LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbWluOiBvcGVyYXRpb25zTWluLFxyXG4gICAgICAgICAgICBtYXg6IG9wZXJhdGlvbnNNYXhcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbWluOiBlbmdpbmVlck1pbixcclxuICAgICAgICAgICAgbWF4OiBlbmdpbmVlck1heFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtaW46IG1hbmFnZW1lbnRNaW4sXHJcbiAgICAgICAgICAgIG1heDogbWFuYWdlbWVudE1heFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd29ya2xvYWQsXHJcbiAgICAgICAgbG9nZ2VyXHJcbiAgICApO1xyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBvY2N1cnJlZCBpbiB3b3JrZXI6ICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IpfWApO1xyXG4gICAgfVxyXG4gICAgZGF0YS5zb3J0KGdldENvbXBhcmF0b3IoQmVuY2htYXJrVHlwZS5PRkZJQ0UsIHNvcnRUeXBlLCBjb21wYXJhdG9yQ3VzdG9tRGF0YSkpO1xyXG5cclxuICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGxvZ2dlci5sb2coYG1heFVzZWRTdGVwOiAke21heFVzZWRTdGVwfWApO1xyXG4gICAgICAgIGlmIChjb3VudCA+PSBtYXhSZXJ1bikge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heFVzZWRTdGVwID09PSBtaW5TdGVwRm9yT2ZmaWNlQmVuY2htYXJrKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIubG9nKFwiUmVydW4gYmVuY2htYXJrIHRvIGdldCBtb3JlIGFjY3VyYXRlIGRhdGFcIik7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEJlc3RSZXN1bHQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgbG9nZ2VyLmxvZyhcIkN1cnJlbnQgYmVzdCByZXN1bHQ6XCIpO1xyXG4gICAgICAgIHByaW50RGF0YUVudHJ5TG9nKGN1cnJlbnRCZXN0UmVzdWx0KTtcclxuICAgICAgICAvLyBEbyBub3QgdXNlIG5vblJuREVtcGxveWVlc1dpdGhSZXF1aXJlbWVudCBpbiBmb2xsb3dpbmcgY2FsY3VsYXRpb25zXHJcbiAgICAgICAgbGV0IG5ld0VuZ2luZWVyTWluID0gTWF0aC5tYXgoY3VycmVudEJlc3RSZXN1bHQuZW5naW5lZXIgLSBtYXhVc2VkU3RlcCwgMSk7XHJcbiAgICAgICAgbGV0IG5ld0VuZ2luZWVyTWF4ID0gTWF0aC5taW4oY3VycmVudEJlc3RSZXN1bHQuZW5naW5lZXIgKyBtYXhVc2VkU3RlcCwgbm9uUm5ERW1wbG95ZWVzIC0gMyk7XHJcbiAgICAgICAgaWYgKGVtcGxveWVlSm9ic1JlcXVpcmVtZW50KSB7XHJcbiAgICAgICAgICAgIG5ld0VuZ2luZWVyTWluID0gZW1wbG95ZWVKb2JzUmVxdWlyZW1lbnQuZW5naW5lZXI7XHJcbiAgICAgICAgICAgIG5ld0VuZ2luZWVyTWF4ID0gZW1wbG95ZWVKb2JzUmVxdWlyZW1lbnQuZW5naW5lZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHNwbGl0V29ya2xvYWQoXHJcbiAgICAgICAgICAgIG5zeCxcclxuICAgICAgICAgICAgZGl2aXNpb24ubmFtZSxcclxuICAgICAgICAgICAgY2l0eSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbWluOiBNYXRoLm1heChjdXJyZW50QmVzdFJlc3VsdC5vcGVyYXRpb25zIC0gbWF4VXNlZFN0ZXAsIDEpLFxyXG4gICAgICAgICAgICAgICAgbWF4OiBNYXRoLm1pbihjdXJyZW50QmVzdFJlc3VsdC5vcGVyYXRpb25zICsgbWF4VXNlZFN0ZXAsIG5vblJuREVtcGxveWVlcyAtIDMpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1pbjogbmV3RW5naW5lZXJNaW4sXHJcbiAgICAgICAgICAgICAgICBtYXg6IG5ld0VuZ2luZWVyTWF4XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1pbjogTWF0aC5tYXgoY3VycmVudEJlc3RSZXN1bHQubWFuYWdlbWVudCAtIG1heFVzZWRTdGVwLCAxKSxcclxuICAgICAgICAgICAgICAgIG1heDogTWF0aC5taW4oY3VycmVudEJlc3RSZXN1bHQubWFuYWdlbWVudCArIG1heFVzZWRTdGVwLCBub25SbkRFbXBsb3llZXMgLSAzKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB3b3JrbG9hZCxcclxuICAgICAgICAgICAgbG9nZ2VyXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBvY2N1cnJlZCBpbiB3b3JrZXI6ICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhLnNvcnQoZ2V0Q29tcGFyYXRvcihCZW5jaG1hcmtUeXBlLk9GRklDRSwgc29ydFR5cGUsIGNvbXBhcmF0b3JDdXN0b21EYXRhKSk7XHJcbiAgICAgICAgKytjb3VudDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZGF0YUZvckxvZ2dpbmcgPSBkYXRhO1xyXG4gICAgaWYgKGRhdGFGb3JMb2dnaW5nLmxlbmd0aCA+IDEwKSB7XHJcbiAgICAgICAgZGF0YUZvckxvZ2dpbmcgPSBkYXRhRm9yTG9nZ2luZy5zbGljZSgtMTApO1xyXG4gICAgfVxyXG4gICAgZGF0YUZvckxvZ2dpbmcuZm9yRWFjaChkYXRhRW50cnkgPT4ge1xyXG4gICAgICAgIHByaW50RGF0YUVudHJ5TG9nKGRhdGFFbnRyeSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG4iXSwKICAibWFwcGluZ3MiOiAiQUFDQSxZQUFZLGFBQWE7QUFFekI7QUFBQSxFQUVJO0FBQUEsRUFFQTtBQUFBLEVBQ0E7QUFBQSxFQUVBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxPQUlHO0FBQ1AsU0FBUSx3QkFBa0MsY0FBYyxvQkFBbUI7QUFDM0U7QUFBQSxFQUNJO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLE9BQ0c7QUFDUCxTQUFRLHVCQUFzQjtBQUk5QixJQUFJLGtCQUFrQixJQUFJLHFCQUFxQixFQUFFLGFBQWE7QUFFOUQsZUFBZSx3QkFBd0IsSUFBdUI7QUFDMUQsTUFBSTtBQUNKLE1BQUksUUFBUTtBQUNaLE1BQUk7QUFDQSxrQkFBYyxNQUFNLE1BQU0sZUFBZTtBQUFBLEVBQzdDLFNBQVMsR0FBRztBQUNSLFlBQVE7QUFBQSxFQUNaO0FBQ0EsTUFBSSxlQUFlLENBQUMsWUFBWSxJQUFJO0FBQ2hDLFlBQVE7QUFBQSxFQUNaO0FBQ0EsTUFBSSxDQUFDLE9BQU87QUFDUixzQkFBa0IsZ0JBQWdCLElBQUkseUJBQTJDO0FBQUEsRUFDckY7QUFDSjtBQW1CQSxlQUFlLGNBQ1gsS0FDQSxjQUNBLE1BQ0EsZUFJQSxhQUlBLGVBSUEsVUFDQSxRQUNhO0FBQ2IsUUFBTSxrQkFBa0IsV0FBVyxXQUFXLHVCQUF1QjtBQUNyRSxRQUFNLFVBQW9CLENBQUM7QUFDM0IsUUFBTSxXQUE0QixDQUFDO0FBQ25DLE1BQUksVUFBVSxjQUFjO0FBQzVCLFFBQU0sT0FBTyxLQUFLLE9BQU8sY0FBYyxNQUFNLGNBQWMsT0FBTyxlQUFlO0FBQ2pGLFFBQU0sY0FBYyxvQ0FBb0MsWUFBWSxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksQ0FBQztBQUMxRixTQUFP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
